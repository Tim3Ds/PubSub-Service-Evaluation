// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messaging.proto

#include "messaging.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace messaging {
PROTOBUF_CONSTEXPR MessageEnvelope_MetadataEntry_DoNotUse::MessageEnvelope_MetadataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MessageEnvelope_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageEnvelope_MetadataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageEnvelope_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MessageEnvelope_MetadataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageEnvelope_MetadataEntry_DoNotUseDefaultTypeInternal _MessageEnvelope_MetadataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MessageEnvelope::MessageEnvelope(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metadata_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.message_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.topic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ack_)*/nullptr
  , /*decltype(_impl_.target_)*/0
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.async_)*/false
  , /*decltype(_impl_.routing_)*/0
  , /*decltype(_impl_.qos_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MessageEnvelopeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageEnvelopeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageEnvelopeDefaultTypeInternal() {}
  union {
    MessageEnvelope _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageEnvelopeDefaultTypeInternal _MessageEnvelope_default_instance_;
PROTOBUF_CONSTEXPR DataMessage::DataMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_value_)*/{}
  , /*decltype(_impl_.message_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DataMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMessageDefaultTypeInternal() {}
  union {
    DataMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMessageDefaultTypeInternal _DataMessage_default_instance_;
PROTOBUF_CONSTEXPR RPCRequest::RPCRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.arguments_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timeout_ms_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RPCRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RPCRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RPCRequestDefaultTypeInternal() {}
  union {
    RPCRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RPCRequestDefaultTypeInternal _RPCRequest_default_instance_;
PROTOBUF_CONSTEXPR RPCResponse::RPCResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RPCResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RPCResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RPCResponseDefaultTypeInternal() {}
  union {
    RPCResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RPCResponseDefaultTypeInternal _RPCResponse_default_instance_;
PROTOBUF_CONSTEXPR Acknowledgment::Acknowledgment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.original_message_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.receiver_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.latency_ms_)*/0
  , /*decltype(_impl_.received_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AcknowledgmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AcknowledgmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AcknowledgmentDefaultTypeInternal() {}
  union {
    Acknowledgment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AcknowledgmentDefaultTypeInternal _Acknowledgment_default_instance_;
PROTOBUF_CONSTEXPR ControlMessage::ControlMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.destination_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlMessageDefaultTypeInternal() {}
  union {
    ControlMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlMessageDefaultTypeInternal _ControlMessage_default_instance_;
PROTOBUF_CONSTEXPR BatchMessage::BatchMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messages_)*/{}
  , /*decltype(_impl_.batch_id_)*/0
  , /*decltype(_impl_.is_last_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchMessageDefaultTypeInternal() {}
  union {
    BatchMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchMessageDefaultTypeInternal _BatchMessage_default_instance_;
PROTOBUF_CONSTEXPR BatchResponse::BatchResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.acknowledgments_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.failed_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchResponseDefaultTypeInternal() {}
  union {
    BatchResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchResponseDefaultTypeInternal _BatchResponse_default_instance_;
PROTOBUF_CONSTEXPR StatsMessage::StatsMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.service_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.messages_sent_)*/int64_t{0}
  , /*decltype(_impl_.messages_received_)*/int64_t{0}
  , /*decltype(_impl_.messages_dropped_)*/int64_t{0}
  , /*decltype(_impl_.avg_latency_ms_)*/0
  , /*decltype(_impl_.throughput_msg_per_sec_)*/0
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsMessageDefaultTypeInternal() {}
  union {
    StatsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsMessageDefaultTypeInternal _StatsMessage_default_instance_;
}  // namespace messaging
static ::_pb::Metadata file_level_metadata_messaging_2eproto[10];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_messaging_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_messaging_2eproto = nullptr;

const uint32_t TableStruct_messaging_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope_MetadataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope_MetadataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope_MetadataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope_MetadataEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.message_id_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.topic_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.payload_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.async_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.routing_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.qos_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::messaging::MessageEnvelope, _impl_.ack_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::DataMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::DataMessage, _impl_.message_name_),
  PROTOBUF_FIELD_OFFSET(::messaging::DataMessage, _impl_.message_value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::RPCRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::RPCRequest, _impl_.method_),
  PROTOBUF_FIELD_OFFSET(::messaging::RPCRequest, _impl_.arguments_),
  PROTOBUF_FIELD_OFFSET(::messaging::RPCRequest, _impl_.timeout_ms_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::RPCResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::RPCResponse, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::messaging::RPCResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::messaging::RPCResponse, _impl_.error_message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::Acknowledgment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::Acknowledgment, _impl_.original_message_id_),
  PROTOBUF_FIELD_OFFSET(::messaging::Acknowledgment, _impl_.received_),
  PROTOBUF_FIELD_OFFSET(::messaging::Acknowledgment, _impl_.latency_ms_),
  PROTOBUF_FIELD_OFFSET(::messaging::Acknowledgment, _impl_.receiver_id_),
  PROTOBUF_FIELD_OFFSET(::messaging::Acknowledgment, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::ControlMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::ControlMessage, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::messaging::ControlMessage, _impl_.source_),
  PROTOBUF_FIELD_OFFSET(::messaging::ControlMessage, _impl_.destination_),
  PROTOBUF_FIELD_OFFSET(::messaging::ControlMessage, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::BatchMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::BatchMessage, _impl_.messages_),
  PROTOBUF_FIELD_OFFSET(::messaging::BatchMessage, _impl_.batch_id_),
  PROTOBUF_FIELD_OFFSET(::messaging::BatchMessage, _impl_.is_last_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::BatchResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::BatchResponse, _impl_.acknowledgments_),
  PROTOBUF_FIELD_OFFSET(::messaging::BatchResponse, _impl_.failed_count_),
  PROTOBUF_FIELD_OFFSET(::messaging::BatchResponse, _impl_.error_message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _impl_.service_name_),
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _impl_.messages_sent_),
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _impl_.messages_received_),
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _impl_.messages_dropped_),
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _impl_.avg_latency_ms_),
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _impl_.throughput_msg_per_sec_),
  PROTOBUF_FIELD_OFFSET(::messaging::StatsMessage, _impl_.timestamp_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::messaging::MessageEnvelope_MetadataEntry_DoNotUse)},
  { 10, -1, -1, sizeof(::messaging::MessageEnvelope)},
  { 27, -1, -1, sizeof(::messaging::DataMessage)},
  { 35, -1, -1, sizeof(::messaging::RPCRequest)},
  { 44, -1, -1, sizeof(::messaging::RPCResponse)},
  { 53, -1, -1, sizeof(::messaging::Acknowledgment)},
  { 64, -1, -1, sizeof(::messaging::ControlMessage)},
  { 74, -1, -1, sizeof(::messaging::BatchMessage)},
  { 83, -1, -1, sizeof(::messaging::BatchResponse)},
  { 92, -1, -1, sizeof(::messaging::StatsMessage)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::messaging::_MessageEnvelope_MetadataEntry_DoNotUse_default_instance_._instance,
  &::messaging::_MessageEnvelope_default_instance_._instance,
  &::messaging::_DataMessage_default_instance_._instance,
  &::messaging::_RPCRequest_default_instance_._instance,
  &::messaging::_RPCResponse_default_instance_._instance,
  &::messaging::_Acknowledgment_default_instance_._instance,
  &::messaging::_ControlMessage_default_instance_._instance,
  &::messaging::_BatchMessage_default_instance_._instance,
  &::messaging::_BatchResponse_default_instance_._instance,
  &::messaging::_StatsMessage_default_instance_._instance,
};

const char descriptor_table_protodef_messaging_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017messaging.proto\022\tmessaging\"\375\002\n\017Message"
  "Envelope\022\022\n\nmessage_id\030\001 \001(\t\022\016\n\006target\030\002"
  " \001(\005\022\r\n\005topic\030\003 \001(\t\022$\n\004type\030\004 \001(\0162\026.mess"
  "aging.MessageType\022\017\n\007payload\030\005 \001(\014\022\r\n\005as"
  "ync\030\006 \001(\010\022\021\n\ttimestamp\030\007 \001(\003\022\'\n\007routing\030"
  "\010 \001(\0162\026.messaging.RoutingMode\022 \n\003qos\030\t \001"
  "(\0162\023.messaging.QoSLevel\022:\n\010metadata\030\n \003("
  "\0132(.messaging.MessageEnvelope.MetadataEn"
  "try\022&\n\003ack\030\013 \001(\0132\031.messaging.Acknowledgm"
  "ent\032/\n\rMetadataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005val"
  "ue\030\002 \001(\t:\0028\001\":\n\013DataMessage\022\024\n\014message_n"
  "ame\030\001 \001(\t\022\025\n\rmessage_value\030\002 \003(\t\"C\n\nRPCR"
  "equest\022\016\n\006method\030\001 \001(\t\022\021\n\targuments\030\002 \001("
  "\014\022\022\n\ntimeout_ms\030\003 \001(\005\"E\n\013RPCResponse\022\017\n\007"
  "success\030\001 \001(\010\022\016\n\006result\030\002 \001(\014\022\025\n\rerror_m"
  "essage\030\003 \001(\t\"x\n\016Acknowledgment\022\033\n\023origin"
  "al_message_id\030\001 \001(\t\022\020\n\010received\030\002 \001(\010\022\022\n"
  "\nlatency_ms\030\003 \001(\001\022\023\n\013receiver_id\030\004 \001(\t\022\016"
  "\n\006status\030\005 \001(\t\"i\n\016ControlMessage\022$\n\004type"
  "\030\001 \001(\0162\026.messaging.ControlType\022\016\n\006source"
  "\030\002 \001(\t\022\023\n\013destination\030\003 \001(\t\022\014\n\004data\030\004 \001("
  "\014\"_\n\014BatchMessage\022,\n\010messages\030\001 \003(\0132\032.me"
  "ssaging.MessageEnvelope\022\020\n\010batch_id\030\002 \001("
  "\005\022\017\n\007is_last\030\003 \001(\010\"p\n\rBatchResponse\0222\n\017a"
  "cknowledgments\030\001 \003(\0132\031.messaging.Acknowl"
  "edgment\022\024\n\014failed_count\030\002 \001(\005\022\025\n\rerror_m"
  "essage\030\003 \001(\t\"\273\001\n\014StatsMessage\022\024\n\014service"
  "_name\030\001 \001(\t\022\025\n\rmessages_sent\030\002 \001(\003\022\031\n\021me"
  "ssages_received\030\003 \001(\003\022\030\n\020messages_droppe"
  "d\030\004 \001(\003\022\026\n\016avg_latency_ms\030\005 \001(\001\022\036\n\026throu"
  "ghput_msg_per_sec\030\006 \001(\001\022\021\n\ttimestamp\030\007 \001"
  "(\003*\201\001\n\013MessageType\022\034\n\030MESSAGE_TYPE_UNSPE"
  "CIFIED\020\000\022\020\n\014DATA_MESSAGE\020\001\022\017\n\013RPC_REQUES"
  "T\020\002\022\020\n\014RPC_RESPONSE\020\003\022\007\n\003ACK\020\004\022\013\n\007CONTRO"
  "L\020\005\022\t\n\005EVENT\020\006*p\n\013RoutingMode\022\027\n\023ROUTING"
  "_UNSPECIFIED\020\000\022\022\n\016POINT_TO_POINT\020\001\022\025\n\021PU"
  "BLISH_SUBSCRIBE\020\002\022\021\n\rREQUEST_REPLY\020\003\022\n\n\006"
  "FANOUT\020\004*V\n\010QoSLevel\022\023\n\017QOS_UNSPECIFIED\020"
  "\000\022\020\n\014AT_MOST_ONCE\020\001\022\021\n\rAT_LEAST_ONCE\020\002\022\020"
  "\n\014EXACTLY_ONCE\020\003*\177\n\013ControlType\022\034\n\030CONTR"
  "OL_TYPE_UNSPECIFIED\020\000\022\010\n\004PING\020\001\022\010\n\004PONG\020"
  "\002\022\014\n\010SHUTDOWN\020\003\022\020\n\014HEALTH_CHECK\020\004\022\r\n\tSUB"
  "SCRIBE\020\005\022\017\n\013UNSUBSCRIBE\020\0062\356\001\n\020MessagingS"
  "ervice\022L\n\016StreamMessages\022\032.messaging.Mes"
  "sageEnvelope\032\032.messaging.MessageEnvelope"
  "(\0010\001\022E\n\013SendMessage\022\032.messaging.MessageE"
  "nvelope\032\032.messaging.MessageEnvelope\022E\n\tS"
  "ubscribe\022\032.messaging.MessageEnvelope\032\032.m"
  "essaging.MessageEnvelope0\001b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_messaging_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_messaging_2eproto = {
    false, false, 1954, descriptor_table_protodef_messaging_2eproto,
    "messaging.proto",
    &descriptor_table_messaging_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_messaging_2eproto::offsets,
    file_level_metadata_messaging_2eproto, file_level_enum_descriptors_messaging_2eproto,
    file_level_service_descriptors_messaging_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_messaging_2eproto_getter() {
  return &descriptor_table_messaging_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_messaging_2eproto(&descriptor_table_messaging_2eproto);
namespace messaging {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messaging_2eproto);
  return file_level_enum_descriptors_messaging_2eproto[0];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoutingMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messaging_2eproto);
  return file_level_enum_descriptors_messaging_2eproto[1];
}
bool RoutingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QoSLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messaging_2eproto);
  return file_level_enum_descriptors_messaging_2eproto[2];
}
bool QoSLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messaging_2eproto);
  return file_level_enum_descriptors_messaging_2eproto[3];
}
bool ControlType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

MessageEnvelope_MetadataEntry_DoNotUse::MessageEnvelope_MetadataEntry_DoNotUse() {}
MessageEnvelope_MetadataEntry_DoNotUse::MessageEnvelope_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MessageEnvelope_MetadataEntry_DoNotUse::MergeFrom(const MessageEnvelope_MetadataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata MessageEnvelope_MetadataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[0]);
}

// ===================================================================

class MessageEnvelope::_Internal {
 public:
  static const ::messaging::Acknowledgment& ack(const MessageEnvelope* msg);
};

const ::messaging::Acknowledgment&
MessageEnvelope::_Internal::ack(const MessageEnvelope* msg) {
  return *msg->_impl_.ack_;
}
MessageEnvelope::MessageEnvelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &MessageEnvelope::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:messaging.MessageEnvelope)
}
MessageEnvelope::MessageEnvelope(const MessageEnvelope& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MessageEnvelope* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.metadata_)*/{}
    , decltype(_impl_.message_id_){}
    , decltype(_impl_.topic_){}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.ack_){nullptr}
    , decltype(_impl_.target_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.async_){}
    , decltype(_impl_.routing_){}
    , decltype(_impl_.qos_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  _impl_.message_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message_id().empty()) {
    _this->_impl_.message_id_.Set(from._internal_message_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_topic().empty()) {
    _this->_impl_.topic_.Set(from._internal_topic(), 
      _this->GetArenaForAllocation());
  }
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payload().empty()) {
    _this->_impl_.payload_.Set(from._internal_payload(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_ack()) {
    _this->_impl_.ack_ = new ::messaging::Acknowledgment(*from._impl_.ack_);
  }
  ::memcpy(&_impl_.target_, &from._impl_.target_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.qos_) -
    reinterpret_cast<char*>(&_impl_.target_)) + sizeof(_impl_.qos_));
  // @@protoc_insertion_point(copy_constructor:messaging.MessageEnvelope)
}

inline void MessageEnvelope::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.metadata_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.message_id_){}
    , decltype(_impl_.topic_){}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.ack_){nullptr}
    , decltype(_impl_.target_){0}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.async_){false}
    , decltype(_impl_.routing_){0}
    , decltype(_impl_.qos_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MessageEnvelope::~MessageEnvelope() {
  // @@protoc_insertion_point(destructor:messaging.MessageEnvelope)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void MessageEnvelope::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.metadata_.Destruct();
  _impl_.metadata_.~MapField();
  _impl_.message_id_.Destroy();
  _impl_.topic_.Destroy();
  _impl_.payload_.Destroy();
  if (this != internal_default_instance()) delete _impl_.ack_;
}

void MessageEnvelope::ArenaDtor(void* object) {
  MessageEnvelope* _this = reinterpret_cast< MessageEnvelope* >(object);
  _this->_impl_.metadata_.Destruct();
}
void MessageEnvelope::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageEnvelope::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.MessageEnvelope)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.message_id_.ClearToEmpty();
  _impl_.topic_.ClearToEmpty();
  _impl_.payload_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.ack_ != nullptr) {
    delete _impl_.ack_;
  }
  _impl_.ack_ = nullptr;
  ::memset(&_impl_.target_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.qos_) -
      reinterpret_cast<char*>(&_impl_.target_)) + sizeof(_impl_.qos_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageEnvelope::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.MessageEnvelope.message_id"));
        } else
          goto handle_unusual;
        continue;
      // int32 target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string topic = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_topic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.MessageEnvelope.topic"));
        } else
          goto handle_unusual;
        continue;
      // .messaging.MessageType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::messaging::MessageType>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes payload = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool async = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.async_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .messaging.RoutingMode routing = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_routing(static_cast<::messaging::RoutingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .messaging.QoSLevel qos = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_qos(static_cast<::messaging::QoSLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> metadata = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.metadata_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .messaging.Acknowledgment ack = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_ack(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageEnvelope::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.MessageEnvelope)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message_id = 1;
  if (!this->_internal_message_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message_id().data(), static_cast<int>(this->_internal_message_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.MessageEnvelope.message_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message_id(), target);
  }

  // int32 target = 2;
  if (this->_internal_target() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_target(), target);
  }

  // string topic = 3;
  if (!this->_internal_topic().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_topic().data(), static_cast<int>(this->_internal_topic().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.MessageEnvelope.topic");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_topic(), target);
  }

  // .messaging.MessageType type = 4;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // bytes payload = 5;
  if (!this->_internal_payload().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_payload(), target);
  }

  // bool async = 6;
  if (this->_internal_async() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_async(), target);
  }

  // int64 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_timestamp(), target);
  }

  // .messaging.RoutingMode routing = 8;
  if (this->_internal_routing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_routing(), target);
  }

  // .messaging.QoSLevel qos = 9;
  if (this->_internal_qos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_qos(), target);
  }

  // map<string, string> metadata = 10;
  if (!this->_internal_metadata().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = MessageEnvelope_MetadataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_metadata();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "messaging.MessageEnvelope.MetadataEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "messaging.MessageEnvelope.MetadataEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .messaging.Acknowledgment ack = 11;
  if (this->_internal_has_ack()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::ack(this),
        _Internal::ack(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.MessageEnvelope)
  return target;
}

size_t MessageEnvelope::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.MessageEnvelope)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> metadata = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_metadata_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_metadata().begin();
      it != this->_internal_metadata().end(); ++it) {
    total_size += MessageEnvelope_MetadataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string message_id = 1;
  if (!this->_internal_message_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_id());
  }

  // string topic = 3;
  if (!this->_internal_topic().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  // bytes payload = 5;
  if (!this->_internal_payload().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_payload());
  }

  // .messaging.Acknowledgment ack = 11;
  if (this->_internal_has_ack()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ack_);
  }

  // int32 target = 2;
  if (this->_internal_target() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target());
  }

  // .messaging.MessageType type = 4;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int64 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  // bool async = 6;
  if (this->_internal_async() != 0) {
    total_size += 1 + 1;
  }

  // .messaging.RoutingMode routing = 8;
  if (this->_internal_routing() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_routing());
  }

  // .messaging.QoSLevel qos = 9;
  if (this->_internal_qos() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_qos());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageEnvelope::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageEnvelope::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageEnvelope::GetClassData() const { return &_class_data_; }


void MessageEnvelope::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MessageEnvelope*>(&to_msg);
  auto& from = static_cast<const MessageEnvelope&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.MessageEnvelope)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_message_id().empty()) {
    _this->_internal_set_message_id(from._internal_message_id());
  }
  if (!from._internal_topic().empty()) {
    _this->_internal_set_topic(from._internal_topic());
  }
  if (!from._internal_payload().empty()) {
    _this->_internal_set_payload(from._internal_payload());
  }
  if (from._internal_has_ack()) {
    _this->_internal_mutable_ack()->::messaging::Acknowledgment::MergeFrom(
        from._internal_ack());
  }
  if (from._internal_target() != 0) {
    _this->_internal_set_target(from._internal_target());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_async() != 0) {
    _this->_internal_set_async(from._internal_async());
  }
  if (from._internal_routing() != 0) {
    _this->_internal_set_routing(from._internal_routing());
  }
  if (from._internal_qos() != 0) {
    _this->_internal_set_qos(from._internal_qos());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageEnvelope::CopyFrom(const MessageEnvelope& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.MessageEnvelope)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageEnvelope::IsInitialized() const {
  return true;
}

void MessageEnvelope::InternalSwap(MessageEnvelope* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_id_, lhs_arena,
      &other->_impl_.message_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.topic_, lhs_arena,
      &other->_impl_.topic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_, lhs_arena,
      &other->_impl_.payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageEnvelope, _impl_.qos_)
      + sizeof(MessageEnvelope::_impl_.qos_)
      - PROTOBUF_FIELD_OFFSET(MessageEnvelope, _impl_.ack_)>(
          reinterpret_cast<char*>(&_impl_.ack_),
          reinterpret_cast<char*>(&other->_impl_.ack_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageEnvelope::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[1]);
}

// ===================================================================

class DataMessage::_Internal {
 public:
};

DataMessage::DataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.DataMessage)
}
DataMessage::DataMessage(const DataMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_value_){from._impl_.message_value_}
    , decltype(_impl_.message_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message_name().empty()) {
    _this->_impl_.message_name_.Set(from._internal_message_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:messaging.DataMessage)
}

inline void DataMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_value_){arena}
    , decltype(_impl_.message_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMessage::~DataMessage() {
  // @@protoc_insertion_point(destructor:messaging.DataMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_value_.~RepeatedPtrField();
  _impl_.message_name_.Destroy();
}

void DataMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.DataMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_value_.Clear();
  _impl_.message_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.DataMessage.message_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string message_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_message_value();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "messaging.DataMessage.message_value"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.DataMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message_name = 1;
  if (!this->_internal_message_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message_name().data(), static_cast<int>(this->_internal_message_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.DataMessage.message_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message_name(), target);
  }

  // repeated string message_value = 2;
  for (int i = 0, n = this->_internal_message_value_size(); i < n; i++) {
    const auto& s = this->_internal_message_value(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.DataMessage.message_value");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.DataMessage)
  return target;
}

size_t DataMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.DataMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string message_value = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.message_value_.size());
  for (int i = 0, n = _impl_.message_value_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.message_value_.Get(i));
  }

  // string message_name = 1;
  if (!this->_internal_message_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataMessage::GetClassData() const { return &_class_data_; }


void DataMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataMessage*>(&to_msg);
  auto& from = static_cast<const DataMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.DataMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.message_value_.MergeFrom(from._impl_.message_value_);
  if (!from._internal_message_name().empty()) {
    _this->_internal_set_message_name(from._internal_message_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataMessage::CopyFrom(const DataMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.DataMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessage::IsInitialized() const {
  return true;
}

void DataMessage::InternalSwap(DataMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.message_value_.InternalSwap(&other->_impl_.message_value_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_name_, lhs_arena,
      &other->_impl_.message_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DataMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[2]);
}

// ===================================================================

class RPCRequest::_Internal {
 public:
};

RPCRequest::RPCRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.RPCRequest)
}
RPCRequest::RPCRequest(const RPCRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RPCRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.method_){}
    , decltype(_impl_.arguments_){}
    , decltype(_impl_.timeout_ms_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    _this->_impl_.method_.Set(from._internal_method(), 
      _this->GetArenaForAllocation());
  }
  _impl_.arguments_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arguments_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_arguments().empty()) {
    _this->_impl_.arguments_.Set(from._internal_arguments(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.timeout_ms_ = from._impl_.timeout_ms_;
  // @@protoc_insertion_point(copy_constructor:messaging.RPCRequest)
}

inline void RPCRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.method_){}
    , decltype(_impl_.arguments_){}
    , decltype(_impl_.timeout_ms_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.arguments_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arguments_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RPCRequest::~RPCRequest() {
  // @@protoc_insertion_point(destructor:messaging.RPCRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RPCRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.method_.Destroy();
  _impl_.arguments_.Destroy();
}

void RPCRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RPCRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.RPCRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.method_.ClearToEmpty();
  _impl_.arguments_.ClearToEmpty();
  _impl_.timeout_ms_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RPCRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string method = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.RPCRequest.method"));
        } else
          goto handle_unusual;
        continue;
      // bytes arguments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_arguments();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 timeout_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RPCRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.RPCRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string method = 1;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.RPCRequest.method");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_method(), target);
  }

  // bytes arguments = 2;
  if (!this->_internal_arguments().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_arguments(), target);
  }

  // int32 timeout_ms = 3;
  if (this->_internal_timeout_ms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_timeout_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.RPCRequest)
  return target;
}

size_t RPCRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.RPCRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string method = 1;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  // bytes arguments = 2;
  if (!this->_internal_arguments().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_arguments());
  }

  // int32 timeout_ms = 3;
  if (this->_internal_timeout_ms() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout_ms());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RPCRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RPCRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RPCRequest::GetClassData() const { return &_class_data_; }


void RPCRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RPCRequest*>(&to_msg);
  auto& from = static_cast<const RPCRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.RPCRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_method().empty()) {
    _this->_internal_set_method(from._internal_method());
  }
  if (!from._internal_arguments().empty()) {
    _this->_internal_set_arguments(from._internal_arguments());
  }
  if (from._internal_timeout_ms() != 0) {
    _this->_internal_set_timeout_ms(from._internal_timeout_ms());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RPCRequest::CopyFrom(const RPCRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.RPCRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RPCRequest::IsInitialized() const {
  return true;
}

void RPCRequest::InternalSwap(RPCRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_, lhs_arena,
      &other->_impl_.method_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.arguments_, lhs_arena,
      &other->_impl_.arguments_, rhs_arena
  );
  swap(_impl_.timeout_ms_, other->_impl_.timeout_ms_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RPCRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[3]);
}

// ===================================================================

class RPCResponse::_Internal {
 public:
};

RPCResponse::RPCResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.RPCResponse)
}
RPCResponse::RPCResponse(const RPCResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RPCResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.result_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.result_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_result().empty()) {
    _this->_impl_.result_.Set(from._internal_result(), 
      _this->GetArenaForAllocation());
  }
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_message().empty()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:messaging.RPCResponse)
}

inline void RPCResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.result_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.result_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RPCResponse::~RPCResponse() {
  // @@protoc_insertion_point(destructor:messaging.RPCResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RPCResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.result_.Destroy();
  _impl_.error_message_.Destroy();
}

void RPCResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RPCResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.RPCResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_.ClearToEmpty();
  _impl_.error_message_.ClearToEmpty();
  _impl_.success_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RPCResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_result();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.RPCResponse.error_message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RPCResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.RPCResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // bytes result = 2;
  if (!this->_internal_result().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_result(), target);
  }

  // string error_message = 3;
  if (!this->_internal_error_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_message().data(), static_cast<int>(this->_internal_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.RPCResponse.error_message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.RPCResponse)
  return target;
}

size_t RPCResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.RPCResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes result = 2;
  if (!this->_internal_result().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_result());
  }

  // string error_message = 3;
  if (!this->_internal_error_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_message());
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RPCResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RPCResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RPCResponse::GetClassData() const { return &_class_data_; }


void RPCResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RPCResponse*>(&to_msg);
  auto& from = static_cast<const RPCResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.RPCResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_result().empty()) {
    _this->_internal_set_result(from._internal_result());
  }
  if (!from._internal_error_message().empty()) {
    _this->_internal_set_error_message(from._internal_error_message());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RPCResponse::CopyFrom(const RPCResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.RPCResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RPCResponse::IsInitialized() const {
  return true;
}

void RPCResponse::InternalSwap(RPCResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.result_, lhs_arena,
      &other->_impl_.result_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RPCResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[4]);
}

// ===================================================================

class Acknowledgment::_Internal {
 public:
};

Acknowledgment::Acknowledgment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.Acknowledgment)
}
Acknowledgment::Acknowledgment(const Acknowledgment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Acknowledgment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.original_message_id_){}
    , decltype(_impl_.receiver_id_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.latency_ms_){}
    , decltype(_impl_.received_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.original_message_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.original_message_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_original_message_id().empty()) {
    _this->_impl_.original_message_id_.Set(from._internal_original_message_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.receiver_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.receiver_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_receiver_id().empty()) {
    _this->_impl_.receiver_id_.Set(from._internal_receiver_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.latency_ms_, &from._impl_.latency_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.received_) -
    reinterpret_cast<char*>(&_impl_.latency_ms_)) + sizeof(_impl_.received_));
  // @@protoc_insertion_point(copy_constructor:messaging.Acknowledgment)
}

inline void Acknowledgment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.original_message_id_){}
    , decltype(_impl_.receiver_id_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.latency_ms_){0}
    , decltype(_impl_.received_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.original_message_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.original_message_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.receiver_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.receiver_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Acknowledgment::~Acknowledgment() {
  // @@protoc_insertion_point(destructor:messaging.Acknowledgment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Acknowledgment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.original_message_id_.Destroy();
  _impl_.receiver_id_.Destroy();
  _impl_.status_.Destroy();
}

void Acknowledgment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Acknowledgment::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.Acknowledgment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.original_message_id_.ClearToEmpty();
  _impl_.receiver_id_.ClearToEmpty();
  _impl_.status_.ClearToEmpty();
  ::memset(&_impl_.latency_ms_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.received_) -
      reinterpret_cast<char*>(&_impl_.latency_ms_)) + sizeof(_impl_.received_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Acknowledgment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string original_message_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_original_message_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.Acknowledgment.original_message_id"));
        } else
          goto handle_unusual;
        continue;
      // bool received = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double latency_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string receiver_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_receiver_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.Acknowledgment.receiver_id"));
        } else
          goto handle_unusual;
        continue;
      // string status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.Acknowledgment.status"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Acknowledgment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.Acknowledgment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string original_message_id = 1;
  if (!this->_internal_original_message_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_original_message_id().data(), static_cast<int>(this->_internal_original_message_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.Acknowledgment.original_message_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_original_message_id(), target);
  }

  // bool received = 2;
  if (this->_internal_received() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_received(), target);
  }

  // double latency_ms = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_latency_ms = this->_internal_latency_ms();
  uint64_t raw_latency_ms;
  memcpy(&raw_latency_ms, &tmp_latency_ms, sizeof(tmp_latency_ms));
  if (raw_latency_ms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_latency_ms(), target);
  }

  // string receiver_id = 4;
  if (!this->_internal_receiver_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_receiver_id().data(), static_cast<int>(this->_internal_receiver_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.Acknowledgment.receiver_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_receiver_id(), target);
  }

  // string status = 5;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.Acknowledgment.status");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.Acknowledgment)
  return target;
}

size_t Acknowledgment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.Acknowledgment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string original_message_id = 1;
  if (!this->_internal_original_message_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_original_message_id());
  }

  // string receiver_id = 4;
  if (!this->_internal_receiver_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_receiver_id());
  }

  // string status = 5;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  // double latency_ms = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_latency_ms = this->_internal_latency_ms();
  uint64_t raw_latency_ms;
  memcpy(&raw_latency_ms, &tmp_latency_ms, sizeof(tmp_latency_ms));
  if (raw_latency_ms != 0) {
    total_size += 1 + 8;
  }

  // bool received = 2;
  if (this->_internal_received() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Acknowledgment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Acknowledgment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Acknowledgment::GetClassData() const { return &_class_data_; }


void Acknowledgment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Acknowledgment*>(&to_msg);
  auto& from = static_cast<const Acknowledgment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.Acknowledgment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_original_message_id().empty()) {
    _this->_internal_set_original_message_id(from._internal_original_message_id());
  }
  if (!from._internal_receiver_id().empty()) {
    _this->_internal_set_receiver_id(from._internal_receiver_id());
  }
  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_latency_ms = from._internal_latency_ms();
  uint64_t raw_latency_ms;
  memcpy(&raw_latency_ms, &tmp_latency_ms, sizeof(tmp_latency_ms));
  if (raw_latency_ms != 0) {
    _this->_internal_set_latency_ms(from._internal_latency_ms());
  }
  if (from._internal_received() != 0) {
    _this->_internal_set_received(from._internal_received());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Acknowledgment::CopyFrom(const Acknowledgment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.Acknowledgment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Acknowledgment::IsInitialized() const {
  return true;
}

void Acknowledgment::InternalSwap(Acknowledgment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.original_message_id_, lhs_arena,
      &other->_impl_.original_message_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.receiver_id_, lhs_arena,
      &other->_impl_.receiver_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Acknowledgment, _impl_.received_)
      + sizeof(Acknowledgment::_impl_.received_)
      - PROTOBUF_FIELD_OFFSET(Acknowledgment, _impl_.latency_ms_)>(
          reinterpret_cast<char*>(&_impl_.latency_ms_),
          reinterpret_cast<char*>(&other->_impl_.latency_ms_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Acknowledgment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[5]);
}

// ===================================================================

class ControlMessage::_Internal {
 public:
};

ControlMessage::ControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.ControlMessage)
}
ControlMessage::ControlMessage(const ControlMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControlMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , decltype(_impl_.destination_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source().empty()) {
    _this->_impl_.source_.Set(from._internal_source(), 
      _this->GetArenaForAllocation());
  }
  _impl_.destination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_destination().empty()) {
    _this->_impl_.destination_.Set(from._internal_destination(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:messaging.ControlMessage)
}

inline void ControlMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , decltype(_impl_.destination_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.destination_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destination_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ControlMessage::~ControlMessage() {
  // @@protoc_insertion_point(destructor:messaging.ControlMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_.Destroy();
  _impl_.destination_.Destroy();
  _impl_.data_.Destroy();
}

void ControlMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.ControlMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_.ClearToEmpty();
  _impl_.destination_.ClearToEmpty();
  _impl_.data_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .messaging.ControlType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::messaging::ControlType>(val));
        } else
          goto handle_unusual;
        continue;
      // string source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.ControlMessage.source"));
        } else
          goto handle_unusual;
        continue;
      // string destination = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_destination();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.ControlMessage.destination"));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ControlMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.ControlMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .messaging.ControlType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string source = 2;
  if (!this->_internal_source().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source().data(), static_cast<int>(this->_internal_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.ControlMessage.source");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_source(), target);
  }

  // string destination = 3;
  if (!this->_internal_destination().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_destination().data(), static_cast<int>(this->_internal_destination().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.ControlMessage.destination");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_destination(), target);
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.ControlMessage)
  return target;
}

size_t ControlMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.ControlMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string source = 2;
  if (!this->_internal_source().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source());
  }

  // string destination = 3;
  if (!this->_internal_destination().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_destination());
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // .messaging.ControlType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlMessage::GetClassData() const { return &_class_data_; }


void ControlMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlMessage*>(&to_msg);
  auto& from = static_cast<const ControlMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.ControlMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_source().empty()) {
    _this->_internal_set_source(from._internal_source());
  }
  if (!from._internal_destination().empty()) {
    _this->_internal_set_destination(from._internal_destination());
  }
  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlMessage::CopyFrom(const ControlMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.ControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlMessage::IsInitialized() const {
  return true;
}

void ControlMessage::InternalSwap(ControlMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_, lhs_arena,
      &other->_impl_.source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.destination_, lhs_arena,
      &other->_impl_.destination_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[6]);
}

// ===================================================================

class BatchMessage::_Internal {
 public:
};

BatchMessage::BatchMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.BatchMessage)
}
BatchMessage::BatchMessage(const BatchMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){from._impl_.messages_}
    , decltype(_impl_.batch_id_){}
    , decltype(_impl_.is_last_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.batch_id_, &from._impl_.batch_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_last_) -
    reinterpret_cast<char*>(&_impl_.batch_id_)) + sizeof(_impl_.is_last_));
  // @@protoc_insertion_point(copy_constructor:messaging.BatchMessage)
}

inline void BatchMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){arena}
    , decltype(_impl_.batch_id_){0}
    , decltype(_impl_.is_last_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchMessage::~BatchMessage() {
  // @@protoc_insertion_point(destructor:messaging.BatchMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.messages_.~RepeatedPtrField();
}

void BatchMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.BatchMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.messages_.Clear();
  ::memset(&_impl_.batch_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_last_) -
      reinterpret_cast<char*>(&_impl_.batch_id_)) + sizeof(_impl_.is_last_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .messaging.MessageEnvelope messages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_messages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 batch_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.batch_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_last = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_last_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.BatchMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .messaging.MessageEnvelope messages = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_messages_size()); i < n; i++) {
    const auto& repfield = this->_internal_messages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 batch_id = 2;
  if (this->_internal_batch_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_batch_id(), target);
  }

  // bool is_last = 3;
  if (this->_internal_is_last() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_last(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.BatchMessage)
  return target;
}

size_t BatchMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.BatchMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .messaging.MessageEnvelope messages = 1;
  total_size += 1UL * this->_internal_messages_size();
  for (const auto& msg : this->_impl_.messages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 batch_id = 2;
  if (this->_internal_batch_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_batch_id());
  }

  // bool is_last = 3;
  if (this->_internal_is_last() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchMessage::GetClassData() const { return &_class_data_; }


void BatchMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchMessage*>(&to_msg);
  auto& from = static_cast<const BatchMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.BatchMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.messages_.MergeFrom(from._impl_.messages_);
  if (from._internal_batch_id() != 0) {
    _this->_internal_set_batch_id(from._internal_batch_id());
  }
  if (from._internal_is_last() != 0) {
    _this->_internal_set_is_last(from._internal_is_last());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchMessage::CopyFrom(const BatchMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.BatchMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchMessage::IsInitialized() const {
  return true;
}

void BatchMessage::InternalSwap(BatchMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.messages_.InternalSwap(&other->_impl_.messages_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchMessage, _impl_.is_last_)
      + sizeof(BatchMessage::_impl_.is_last_)
      - PROTOBUF_FIELD_OFFSET(BatchMessage, _impl_.batch_id_)>(
          reinterpret_cast<char*>(&_impl_.batch_id_),
          reinterpret_cast<char*>(&other->_impl_.batch_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[7]);
}

// ===================================================================

class BatchResponse::_Internal {
 public:
};

BatchResponse::BatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.BatchResponse)
}
BatchResponse::BatchResponse(const BatchResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.acknowledgments_){from._impl_.acknowledgments_}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.failed_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_message().empty()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.failed_count_ = from._impl_.failed_count_;
  // @@protoc_insertion_point(copy_constructor:messaging.BatchResponse)
}

inline void BatchResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.acknowledgments_){arena}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.failed_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BatchResponse::~BatchResponse() {
  // @@protoc_insertion_point(destructor:messaging.BatchResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.acknowledgments_.~RepeatedPtrField();
  _impl_.error_message_.Destroy();
}

void BatchResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.BatchResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.acknowledgments_.Clear();
  _impl_.error_message_.ClearToEmpty();
  _impl_.failed_count_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .messaging.Acknowledgment acknowledgments = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_acknowledgments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 failed_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.failed_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.BatchResponse.error_message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.BatchResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .messaging.Acknowledgment acknowledgments = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_acknowledgments_size()); i < n; i++) {
    const auto& repfield = this->_internal_acknowledgments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 failed_count = 2;
  if (this->_internal_failed_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_failed_count(), target);
  }

  // string error_message = 3;
  if (!this->_internal_error_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_message().data(), static_cast<int>(this->_internal_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.BatchResponse.error_message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.BatchResponse)
  return target;
}

size_t BatchResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.BatchResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .messaging.Acknowledgment acknowledgments = 1;
  total_size += 1UL * this->_internal_acknowledgments_size();
  for (const auto& msg : this->_impl_.acknowledgments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string error_message = 3;
  if (!this->_internal_error_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_message());
  }

  // int32 failed_count = 2;
  if (this->_internal_failed_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_failed_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchResponse::GetClassData() const { return &_class_data_; }


void BatchResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchResponse*>(&to_msg);
  auto& from = static_cast<const BatchResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.BatchResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.acknowledgments_.MergeFrom(from._impl_.acknowledgments_);
  if (!from._internal_error_message().empty()) {
    _this->_internal_set_error_message(from._internal_error_message());
  }
  if (from._internal_failed_count() != 0) {
    _this->_internal_set_failed_count(from._internal_failed_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchResponse::CopyFrom(const BatchResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.BatchResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchResponse::IsInitialized() const {
  return true;
}

void BatchResponse::InternalSwap(BatchResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.acknowledgments_.InternalSwap(&other->_impl_.acknowledgments_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  swap(_impl_.failed_count_, other->_impl_.failed_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[8]);
}

// ===================================================================

class StatsMessage::_Internal {
 public:
};

StatsMessage::StatsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:messaging.StatsMessage)
}
StatsMessage::StatsMessage(const StatsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.service_name_){}
    , decltype(_impl_.messages_sent_){}
    , decltype(_impl_.messages_received_){}
    , decltype(_impl_.messages_dropped_){}
    , decltype(_impl_.avg_latency_ms_){}
    , decltype(_impl_.throughput_msg_per_sec_){}
    , decltype(_impl_.timestamp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.service_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_service_name().empty()) {
    _this->_impl_.service_name_.Set(from._internal_service_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.messages_sent_, &from._impl_.messages_sent_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.messages_sent_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:messaging.StatsMessage)
}

inline void StatsMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.service_name_){}
    , decltype(_impl_.messages_sent_){int64_t{0}}
    , decltype(_impl_.messages_received_){int64_t{0}}
    , decltype(_impl_.messages_dropped_){int64_t{0}}
    , decltype(_impl_.avg_latency_ms_){0}
    , decltype(_impl_.throughput_msg_per_sec_){0}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.service_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsMessage::~StatsMessage() {
  // @@protoc_insertion_point(destructor:messaging.StatsMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_name_.Destroy();
}

void StatsMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:messaging.StatsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_name_.ClearToEmpty();
  ::memset(&_impl_.messages_sent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.timestamp_) -
      reinterpret_cast<char*>(&_impl_.messages_sent_)) + sizeof(_impl_.timestamp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string service_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "messaging.StatsMessage.service_name"));
        } else
          goto handle_unusual;
        continue;
      // int64 messages_sent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.messages_sent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 messages_received = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.messages_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 messages_dropped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.messages_dropped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double avg_latency_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.avg_latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double throughput_msg_per_sec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.throughput_msg_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:messaging.StatsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string service_name = 1;
  if (!this->_internal_service_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_service_name().data(), static_cast<int>(this->_internal_service_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "messaging.StatsMessage.service_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service_name(), target);
  }

  // int64 messages_sent = 2;
  if (this->_internal_messages_sent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_messages_sent(), target);
  }

  // int64 messages_received = 3;
  if (this->_internal_messages_received() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_messages_received(), target);
  }

  // int64 messages_dropped = 4;
  if (this->_internal_messages_dropped() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_messages_dropped(), target);
  }

  // double avg_latency_ms = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_avg_latency_ms = this->_internal_avg_latency_ms();
  uint64_t raw_avg_latency_ms;
  memcpy(&raw_avg_latency_ms, &tmp_avg_latency_ms, sizeof(tmp_avg_latency_ms));
  if (raw_avg_latency_ms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_avg_latency_ms(), target);
  }

  // double throughput_msg_per_sec = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_throughput_msg_per_sec = this->_internal_throughput_msg_per_sec();
  uint64_t raw_throughput_msg_per_sec;
  memcpy(&raw_throughput_msg_per_sec, &tmp_throughput_msg_per_sec, sizeof(tmp_throughput_msg_per_sec));
  if (raw_throughput_msg_per_sec != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_throughput_msg_per_sec(), target);
  }

  // int64 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:messaging.StatsMessage)
  return target;
}

size_t StatsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:messaging.StatsMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string service_name = 1;
  if (!this->_internal_service_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service_name());
  }

  // int64 messages_sent = 2;
  if (this->_internal_messages_sent() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_messages_sent());
  }

  // int64 messages_received = 3;
  if (this->_internal_messages_received() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_messages_received());
  }

  // int64 messages_dropped = 4;
  if (this->_internal_messages_dropped() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_messages_dropped());
  }

  // double avg_latency_ms = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_avg_latency_ms = this->_internal_avg_latency_ms();
  uint64_t raw_avg_latency_ms;
  memcpy(&raw_avg_latency_ms, &tmp_avg_latency_ms, sizeof(tmp_avg_latency_ms));
  if (raw_avg_latency_ms != 0) {
    total_size += 1 + 8;
  }

  // double throughput_msg_per_sec = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_throughput_msg_per_sec = this->_internal_throughput_msg_per_sec();
  uint64_t raw_throughput_msg_per_sec;
  memcpy(&raw_throughput_msg_per_sec, &tmp_throughput_msg_per_sec, sizeof(tmp_throughput_msg_per_sec));
  if (raw_throughput_msg_per_sec != 0) {
    total_size += 1 + 8;
  }

  // int64 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsMessage::GetClassData() const { return &_class_data_; }


void StatsMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsMessage*>(&to_msg);
  auto& from = static_cast<const StatsMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:messaging.StatsMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_service_name().empty()) {
    _this->_internal_set_service_name(from._internal_service_name());
  }
  if (from._internal_messages_sent() != 0) {
    _this->_internal_set_messages_sent(from._internal_messages_sent());
  }
  if (from._internal_messages_received() != 0) {
    _this->_internal_set_messages_received(from._internal_messages_received());
  }
  if (from._internal_messages_dropped() != 0) {
    _this->_internal_set_messages_dropped(from._internal_messages_dropped());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_avg_latency_ms = from._internal_avg_latency_ms();
  uint64_t raw_avg_latency_ms;
  memcpy(&raw_avg_latency_ms, &tmp_avg_latency_ms, sizeof(tmp_avg_latency_ms));
  if (raw_avg_latency_ms != 0) {
    _this->_internal_set_avg_latency_ms(from._internal_avg_latency_ms());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_throughput_msg_per_sec = from._internal_throughput_msg_per_sec();
  uint64_t raw_throughput_msg_per_sec;
  memcpy(&raw_throughput_msg_per_sec, &tmp_throughput_msg_per_sec, sizeof(tmp_throughput_msg_per_sec));
  if (raw_throughput_msg_per_sec != 0) {
    _this->_internal_set_throughput_msg_per_sec(from._internal_throughput_msg_per_sec());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsMessage::CopyFrom(const StatsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:messaging.StatsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsMessage::IsInitialized() const {
  return true;
}

void StatsMessage::InternalSwap(StatsMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.service_name_, lhs_arena,
      &other->_impl_.service_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatsMessage, _impl_.timestamp_)
      + sizeof(StatsMessage::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StatsMessage, _impl_.messages_sent_)>(
          reinterpret_cast<char*>(&_impl_.messages_sent_),
          reinterpret_cast<char*>(&other->_impl_.messages_sent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messaging_2eproto_getter, &descriptor_table_messaging_2eproto_once,
      file_level_metadata_messaging_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace messaging
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::messaging::MessageEnvelope_MetadataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::messaging::MessageEnvelope_MetadataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::MessageEnvelope_MetadataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::MessageEnvelope*
Arena::CreateMaybeMessage< ::messaging::MessageEnvelope >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::MessageEnvelope >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::DataMessage*
Arena::CreateMaybeMessage< ::messaging::DataMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::DataMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::RPCRequest*
Arena::CreateMaybeMessage< ::messaging::RPCRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::RPCRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::RPCResponse*
Arena::CreateMaybeMessage< ::messaging::RPCResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::RPCResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::Acknowledgment*
Arena::CreateMaybeMessage< ::messaging::Acknowledgment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::Acknowledgment >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::ControlMessage*
Arena::CreateMaybeMessage< ::messaging::ControlMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::ControlMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::BatchMessage*
Arena::CreateMaybeMessage< ::messaging::BatchMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::BatchMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::BatchResponse*
Arena::CreateMaybeMessage< ::messaging::BatchResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::BatchResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::messaging::StatsMessage*
Arena::CreateMaybeMessage< ::messaging::StatsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::messaging::StatsMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
